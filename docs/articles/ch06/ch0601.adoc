:toc:
:doctype: book
:icons: font
:icon-set: font-awesome
:source-highlighter: highlightjs
:toclevels: 4
:sectlinks:
:author: "mon0mon"
:hardbreaks:

== 6.1 함수 추출하기 (Extract Function)

> 반대 리팩터링: 함수 인라인하기^6.2절^
> 1판에서의 이름 : 메서드 추출

[open]
.리팩토링 이전
--
[source,kotlin]
----
fun printOwing(invoice: Invoice) {
    printBanner()
    val outstanding = calculateOutstanding()

    //  세부 사항 출력
    println("고객명 : ${invoice.customer}")
    println("채무액: $outstanding")
}
----
--

[open]
.리팩토링 이후
--
[source,kotlin]
----
fun printOwing(invoice: Invoice) {
    printBanner()
    val outstanding = calculateOutstanding()

    printDetails(invoice, outstanding)
}

fun printDetails(invoice: Invoice, outstanding: Int) {
    println("고객명 : ${invoice.customer}")
    println("채무액: $outstanding")
}
----
--

### 배경

`함수 추출하기`는 가장 많이 사용하는 리팩터링 중 하나
메소드(method), 프로시저(procedure), 서브루틴(subroutine)에도 동일하게 적용

.과정
. 코드가 어떤 일을 하는지 파악
. 독립된 함수로 추출
. 목적에 맞는 이름 붙히기

.코드를 독립된 함수로 묶는 기준
. 길이를 기준으로 삼기
* 함수 하나가 한 화면을 넘어가지 않기
. 재사용성을 기준으로 삼기
* 두 번 이상 사용될 코드는 함수로 만들기
* 한 번만 쓰이는 코드는 인라인 상태로 놔두기
. [.underline]#목적과 구현을 분리#
* 코드를 봤을 때, 무슨 일을 파악하는지 어렵다면, 함수로 추출
* 함수의 목적과 코드 본문과 분리

함수의 길이를 지나치게 신경쓰지는 않기
코드의 `목적(강조)` 과 `구현(반전)` 사이의 간극을 신경쓰기

함수의 길이가 짧다고 성능에 큰 영향을 주지 않음
오히려 캐싱에 유리하기에, 성능에 도움을 줄 수도 있음
성능 최적화와 관련해서는 되도록 고려하지 말 것

짧은 함수의 강점은 적절한 이름을 통해서 발휘됨
함수의 목적을 설명하는 주석이 첨부되어있는 경우, 이름 지을 때 참고할 것

### 과정

. 함수를 새로 만들고 목적을 잘 드러내는 이름을 붙힌다 (`어떻게` 가 아닌 `무엇을` 하는지가 드러나야 한다)
* 대상 코드가 간단하더라도, 함수로 뽑아서 목적이 잘 드러나는 이름을 붙힐 수 있다면 추출하기
** 이름이 떠오르지 않으면, 함수로 추출하면 안된다는 신호
** 다만 추출하는 과정에서 좋은 이름이 떠오를 수 있기에, 처음부터 최선의 이름을 짓고 시작할 필요는 없음
* 함수 추출이 효과적이지 않으면, 다시 인라인으로 되돌리기
* 중첩 함수를 지원하는 언어의 경우 추출한 함수를 원래 함수로 중첩시키기
** 유효범위를 벗어난 변수를 처리하는 작업을 줄일 수 있음
** 함수 위치를 변경해야할 때는 함수 옮기기^8.1절^를 적용

. 추출할 코드를 원본 함수에서 복사하여 새 함수에 붙여넣기

. 추출한 코드 중 원본 함수의 지역 변수를 참조하거나 추출한 함수의 유효범위를 벗어나는 변수는 없는지 검사, 있다면 매개변수로 전달하기
* 원본 함수의 중첩 함수로 추출할 때는 이런 문제가 생기지 않음
* 사용하지만 값이 바뀌지 변수는 매개변수로 전달받기
* 추출한 코드에서만 사용하는 변수는 함수 안에서 선언하도록 수정
* 값이 변경되는 변수 중에서 값으로 전달되는 것들은 주의해서 처리
** 변수가 하나일 경우에는 질의 함수로 추출해서 변수에 대입하기
* 값을 수정하는 지역 변수가 너무 많을 경우
** 함수 추출을 멈추고, 변수 쪼개기^9.1절^나 질의 함수로 바꾸기^7.4절^ 적용해보기

. 변수를 다 처리한 이후에 컴파일
* 컴파일을 통해, 리팩토링 이후에 오류가 있는지 확인

. 원본 함수에서 추출한 코드 부분을 새로 만든 함수를 호출하는 문장으로 변경 (추출한 함수로 위임)

. 테스트

. 다른 코드에 방금 추출한 것과 똑같거나 비슷한 코드가 없는지 찾기, 있을 경우 추출한 새 함수를 호출하도록 변경할 지 검토 (인라인 코드를 함수 호출로 바꾸기^8.5절^)
* IDE에서 중복 또는 비슷한 코드를 찾아주는 리팩터링 기능이 있는지 확인
* 기능이 없을 경우 검색 기능을 활용할 것

### 예시

include::../subsections/ch06/01/ch0601_01.adoc[]

include::../subsections/ch06/01/ch0601_02.adoc[]

include::../subsections/ch06/01/ch0601_03.adoc[]
