# Chapter 3 코드에서 나는 악취

<details>
<summary>목차</summary>

<!-- TOC -->
* [Chapter 3 코드에서 나는 악취](#chapter-3-코드에서-나는-악취)
  * [3.1 기이한 이름 (Mysterious Name)](#31-기이한-이름-mysterious-name)
  * [3.2 중복 코드 (Duplicated Code)](#32-중복-코드-duplicated-code)
  * [3.3 긴 함수 (Long Function)](#33-긴-함수-long-function)
  * [3.4 긴 매개변수 목록 (Long Parameter List)](#34-긴-매개변수-목록-long-parameter-list)
  * [3.5 전역 데이터 (Global Data)](#35-전역-데이터-global-data)
  * [3.6 가변 데이터 (Mutable Data)](#36-가변-데이터-mutable-data)
  * [3.7 뒤엉킨 변경 (Divergent Change)](#37-뒤엉킨-변경-divergent-change)
  * [3.8 산탄총 수술 (Shotgun Surgery)](#38-산탄총-수술-shotgun-surgery)
  * [3.9 기능 편애 (Feature Envy)](#39-기능-편애-feature-envy)
  * [3.10 데이터 뭉치 (Data Clumps)](#310-데이터-뭉치-data-clumps)
  * [3.11 기본형 집착 (Primitive Obsession)](#311-기본형-집착-primitive-obsession)
  * [3.12 반복되는 switch 문 (Repeated Switches)](#312-반복되는-switch-문-repeated-switches)
  * [3.13 반복문 (Loops)](#313-반복문-loops)
  * [3.14 성의 없는 요소 (Lazy Element)](#314-성의-없는-요소-lazy-element)
  * [3.15 추측성 일반화 (Speculative Generality)](#315-추측성-일반화-speculative-generality)
  * [3.16 임시 필드 (Temporary Field)](#316-임시-필드-temporary-field)
  * [3.17 메시지 체인 (Message Chains)](#317-메시지-체인-message-chains)
  * [3.18 중개자 (Middle Man)](#318-중개자-middle-man)
  * [3.19 내부자 거래 (Insider Trading)](#319-내부자-거래-insider-trading)
  * [3.20 거대한 클래스 (Large Class)](#320-거대한-클래스-large-class)
  * [3.21 서로 다른 인터페이스의 대안 클래스들 (Alternative Classes with Different Interfaces)](#321-서로-다른-인터페이스의-대안-클래스들-alternative-classes-with-different-interfaces)
  * [3.22 데이터 클래스 (Data Class)](#322-데이터-클래스-data-class)
* [3.23 상속 포기 (Refused Bequest)](#323-상속-포기-refused-bequest)
  * [3.24 주석 (Comments)](#324-주석-comments)
<!-- TOC -->

</details>

| 냄새(Smell)

리팩터링할 '시점'을 설명하는데 사용되는 비유<br>
냄새의 단계에서 적극적으로 리팩터링을 적용

## 3.1 기이한 이름 (Mysterious Name)

코드는 명료하게 표현되어야 함<br>
이 중 가장 중요한 요소는 `이름`
- 이름만 보고도 함수, 모듈, 변수, 클래스가 어떤 일을 하고, 어떻게 사용되는지 알 수 있어야 함

<br>
리팩터링 간에도 주기적으로 이름을 변경함

- 함수 선언 바꾸기 <sup>6.5절</sup> (함수 이름을 변경할 때 사용)
- 변수 이름 바꾸기 <sup>6.7절</sup>
- 필드 이름 바꾸기 <sup>9.2절</sup>

<br>
마땅한 이름이 떠오르지 않을 때는, 설계에 근본적인 문제가 숨어있을 가능성이 높음<br>
이름을 정리 하면서, 같이 코드도 간결해지는 경우가 많음


## 3.2 중복 코드 (Duplicated Code)

중복된 코드를 사용할 때 코드간에 차이점은 없는지 주의 깊게 살펴봐야하는 부담이 생김<br>
따라서 똑같은 코드 구조가 여러 곳에서 반복될 때는, 하나로 통합 해야 한다<br>
- 문장 슬라이드 하기 <sup>8.6절</sup>
  - 함수 추출하기 이전에, 비슷한 곳을 모아서 쉽게 적용할 수 있도록 함
- 함수 추출하기 <sup>6.1절</sup>
  - 추출된 메소드를 호출하게 수정
- 메소드 올리기 <sup>12.1절</sup>
  - 같은 부모로 파생된 서브 클래스에서 코드가 중복되어있을 때는, 부모로 코드 이동


## 3.3 긴 함수 (Long Function)

작은 함수 단위 코드는 내부적으로 서브루틴 호출로 이루어진다<br>
과거에는 이러한 호출 비용을 최소화 시키고자, 짧은 함수는 지양했다

현대 언어는 이러한 호출 비용이 거의 없지만, 코드의 흐름에 따라 함수를 이동할 때는 코드를 읽는 사람 입장에서 부담이 크다<br>
함수의 이름을 잘 지어두면, 함수의 동작을 파악할 수 있기 때문에 함수를 따라 이동할 필요가 없어진다

함수의 의도(intention)이 더 잘 드러나도록 이름을 짓는다<br>
핵심은 `함수의 목적과 구현 코드간의 괴리`가 얼마나 큰가이다<br>
어떤 작업을 하는지 코드가 잘 설명해주지 못할 때, 함수로 만드는 것이 유리하다

- 함수 추출하기 <sup>6.1절</sup>
- 임시 변수를 질의 함수로 바꾸기 <sup>7.4절</sup>
- 매개변수 객체 만들기 <sup>6.8</sup>
- 객체 통째로 넘기기 <sup>11.4절</sup>
- 함수를 명령으로 바꾸기 <sup>11.9절</sup>
- 조건문 분해하기 <sup>10.1절</sup>
  - 조건부 로직을 다형성으로 바꾸기 <sup>10.4절</sup>
- 반복문 쪼개기 <sup>8.7절</sup>


## 3.4 긴 매개변수 목록 (Long Parameter List)

길어진 매개변수 목록은 그 자체로 이해하기 어려울 때가 많음
- 매개변수를 질의 함수로 바꾸기 <sup>11.5절</sup>
- 객체 통째로 넘기기 <sup>11.4절</sup>
- 매개변수 객체 만들기 <sup>6.8절</sup>
- 플래그 인수 제거하기 <sup>11.3절</sup>
- 여러 함수를 클래스로 묶기 <sup>6.9절</sup>


## 3.5 전역 데이터 (Global Data)

전역 데이터의 가장 큰 문제는, 코드베이스 어디에서든 수정 가능하며, 누가 값을 바꿔는지 찾아낼 수 없다는 점이다<br>
클래스 변수와 싱글톤에서도 동일한 문제가 발생한다
- 변수 캡슐화 하기 <sup>6.6절</sup>
  - 다른 코드에 영향을 줄 수 있는 데이터에 대해, 해당 기법을 적용한다
  - 데이터에 접근하는 함수나, 접근을 통제할 수 있게 된다
  - 되도록 접근 범위를 클래스나 모듈 수준으로 하는 것이 좋다


## 3.6 가변 데이터 (Mutable Data)

데이터 변경으로 인해, 예상치 못한 결과나 버그가 유발되는 경우가 있다<br>
이러한 이유로 인해 함수형 프로그래밍(Fucntional Programming)에서는 데이터를 불변으로 설정한다
- 변수 캡슐화하기 <sup>6.6절</sup>
- 변수 쪼개기 <sup>9.1절</sup>
- 문장 슬라이드하기 <sup>8.6절</sup>
- 함수 추출하기 <sup>6.1절</sup>
- 질의 함수와 변경 함수 분리하기 <sup>11.1절</sup>
- 세터 제거하기 <sup>11.7절</sup>
- 파생 변수를 질의 함수로 바꾸기 <sup>9.3절</sup>
- 여러 함수를 클래스로 묶기 <sup>6.9절</sup> & 여러 함수를 변환 함수로 묶기 <sup>6.10절</sup> 
  - 유효 범위가 작다면 문제의 소지도 작지만, 나중에 유효범위가 커질 수도 있다
  - 이 경우 코드의 유효 범위를 제한
  - 참조를 값으로 바꾸기 <sup>9.4절</sup>


## 3.7 뒤엉킨 변경 (Divergent Change)

단일 책임 원칙 (Single Responsibility Principle)이 제대로 지켜지지 않을 때 발생<br>
하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다
- 단계 쪼개기 <sup>6.11절</sup>
  - 다음 맥락에 필요한 데이터를 특정한 데이터 구조로 담아 전달하는 방식으로 단계 분리
- 함수 옮기기 <sup>8.1절</sup>
  - 맥락에 해당하는 적당한 모듈을 만들어 관련 함수를 모음
- 함수 추출하기 <sup>6.1절</sup>
- 클래스 추출하기 <sup>7.5절</sup>


## 3.8 산탄총 수술 (Shotgun Surgery)

| 공통점
- 원인
  - 맥락을 잘 구분하지 못함
- 해법 (원리)
  - 맥락을 명확히 구분

| 차이점

|           | 뒤엉킨 변경       | 산탄총 수술      |
|-----------|--------------|-------------|
| 발생 과정(현상) | 한 코드에 섞여 들어감 | 여러 코드에 흩뿌려짐 |
| 해법(실제 행동) | 맥락별로 분리      | 맥락별로 모음     |


뒤엉킨 변경<sup>3.7절</sup>과 비슷하지만 반대<br>
코드를 변경할 때마다 자잘하게 수정해야할 클래스가 많을 때 발생<br>
변경해야할 코드가 전반에 퍼져있다면, 찾기도 어렵고 수정해야할 곳을 놓치지 쉬움
- 함수 옮기기 <sup>8.1절</sup>
- 필드 옮기기 <sup>8.2절</sup>
- 여러 함수를  클래스로 묶기 <sup>6.9절</sup>
- 여러 함수를 변환 함수로 묶기 <sup>6.10절</sup>
- 단계 쪼개기 <sup>6.11절</sup>
- 함수 인라인 하기 <sup>6.2절</sup>
- 클래스 인라인 하기 <sup>7.6절</sup>

## 3.9 기능 편애 (Feature Envy)

프로그램을 모듈화 할 대는 코드를 여러 영역으로 나눔
- 영역 내에서의 상호작용은 최대화 (응집도 Cohesion)
- 영역 간에 일어나는 상호작용은 최소화 (결합도 Coupling)

기능 편애는 어떤 함수가 자기가 속한 모듈보다 다른 모듈의 상호작용이 더 많을 때 발생
- 함수 옮기기 <sup>8.1절</sup>
  - 함수와 데이터를 밀접한 곳으로 이동
- 함수 추출하기 <sup>6.1절</sup> & 함수 옮기기 <sup>8.1절</sup>
  - 함수의 일부를 독립된 함수로 추출

뒤엉킨 변경 냄새를 없앨 때 활용하는 패턴
- 전략 패턴 (Strategy Pattern)
- 방문자 패턴 (Visitor Pattern)
- 자기 위임 (Self Delegation)


## 3.10 데이터 뭉치 (Data Clumps)

연관되어 있는 데이터는, 서로 가까운 곳에 위치하도록 해야함
- 클래스 추출하기 <sup>7.5절</sup>
  - 새로운 클래스 형태를 통해, 코드의 냄새를 최소화
- 매개변수 객체 만들기 <sup>6.8절</sup>
- 객체 통째로 넘기기 <sup>11.4절</sup>


## 3.11 기본형 집착 (Primitive Obsession)

주어진 문제에 맞는 데이터 타입을 사용 또는 생성하기 보다, 기본형만을 사용하는 형태<br>
일반적으로 문자열을 다루는 코드에서 자주 보이는 문제이며, 문자열화된(stringly typed) 변수라는 이름도 존재함<br>
- 기본형을 객체로 바꾸기 <sup>7.3절</sup>
- 타입 코드를 서브클래스로 바꾸기 <sup>12.6절</sup>
- 조건부 로직을 다형성으로 바꾸기 <sup>10.4절</sup>
- 클래스 추출하기 <sup>7.5절</sup>
- 매개변수 객체 만들기 <sup>6.8절</sup>


## 3.12 반복되는 switch 문 (Repeated Switches)

중복된 switch 문이 문제가 되는 경우는, 조건이 추가될 때마다 다른 switch문도 모두 변경해야하기 때문<br>
- 조건부 로직을 다형성으로 바꾸기 <sup>10.4절</sup>


## 3.13 반복문 (Loops)

현재는 일급 함수(First-Class Function)을 지원하는 언어가 다양해졌기에, 반복문을 제거할 수 있음
- 반복문을 파이프라인으로 바꾸기 <sup>8.8절</sup>


## 3.14 성의 없는 요소 (Lazy Element)

불필요한 코드인 경우에는 리팩터링을 거쳐서, 삭제하거나 축소하는 것이 좋음
- 함수 인라인하기 <sup>6.2절</sup>
- 클래스 인라인하기 <sup>7.6절</sup>
- 계층 합치기 <sup>12.9절</sup>


## 3.15 추측성 일반화 (Speculative Generality)

미래에 필요할 것이라는 추측으로, 지금 당장은 필요없는 로직을 작성해둔 코드에서 발생<br>
지금 필요하지 않는 코드는 제거 할 필요가 있음
- 계층 합치기 <sup>12.9절</sup>
- 함수 인라인하기 <sup>6.2절</sup>
- 클래스 인라인하기 <sup>7.6절</sup>
- 함수 선언 바꾸기 <sup>6.5절</sup>
- 죽은 코드 제거하기 <sup>8.9절</sup>


## 3.16 임시 필드 (Temporary Field)

특정 상황에서만 값이 설정되는 필드<br>
사용자 입장에서는 쓰이지 않는 것처럼 보이는 필드의 존재에 대해서 고민하게됨
- 클래스 추출하기 <sup>7.5절</sup>
- 함수 옮기기 <sup>8.1절</sup>
- 특이 케이스 추가하기 <sup>10.5절</sup>


## 3.17 메시지 체인 (Message Chains)

객체 간의 요청이 연쇄적으로 이어지는 코드를 말함<br>
이 경우 클라이언트가 객체 내비게이션 구조에 종속되었음을 의미함
- 위임 숨기기 <sup>7.7절</sup>
- 함수 추출하기 <sup>6.1절</sup>
- 함수 옮기기 <sup>8.1절</sup>


## 3.18 중개자 (Middle Man)

객체의 대표적 기능으로, 외부로부터 세부사항을 숨겨주는 캡슐화(Encapsulation)이 있음<br>
캡슐화하는 과정에서 위임(Delegation)이 자주 활용됨
- 중개자 제거하기 <sup>7.8절</sup>


## 3.19 내부자 거래 (Insider Trading)

모듈간의 의존도를 낮추고, 모듈 내의 결합도를 높이기 위한 방법<br>
외부 모듈의 호출을 최소화 하고, 투명하게 처리
- 함수 옮기기 <sup>8.1절</sup>
- 필드 옮기기 <sup>8.2절</sup>
- 위임 숨기기 <sup>7.7절</sup>
- 서브클래스를 위임으로 바꾸기 <sup>12.10절</sup>
- 슈퍼클래스를 위임으로 바꾸기 <sup>12.11절</sup>


## 3.20 거대한 클래스 (Large Class)

클래스에서 많은 기능을 수행하다보면, 중복된 코드가 발생
이 경우 클래스의 중복코드를 최대한 자체적으로 제거하는 것이 가장 좋음
- 클래스 추출하기 <sup>7.5절</sup>
  - 같은 필드에 넣어두는 것이 합당한 필드끼리 선택
  - 대개 접두어나 접미어가 같은 필드들
- 슈퍼클래스 추출하기 <sup>12.8절</sup>
- 타입 코드를 서브클래스로 바꾸기 <sup>12.6절</sup>


## 3.21 서로 다른 인터페이스의 대안 클래스들 (Alternative Classes with Different Interfaces)

클래스를 교체하는 경우에는, 동일한 인터페이스를 상속받은 클래스로 가능
- 함수 선언 바꾸기 <sup>6.5절</sup>
- 함수 옮기기 <sup>8.1절</sup>
- 슈퍼클래스 추출하기 <sup>12.8절</sup>


## 3.22 데이터 클래스 (Data Class)

데이터 클래스란 데이터 필드와 Getter/Setter로 메소드로 이루어진 클래스를 말함
- 레코드 캡슐화하기 <sup>7.1절</sup>
- 세터 제거하기 <sup>11.7절</sup>
- 함수 옮기기 <sup>8.1절</sup>
- 함수 추출하기 <sup>6.1절</sup>
- 단계 쪼개기 <sup>6.11절</sup>


# 3.23 상속 포기 (Refused Bequest)

슈퍼클래스로부터 부분적으로 상속이 필요한 경우는 계층 구조가 잘못 설계된 것
- 메소드 내리기 <sup>12.4절</sup> & 필드 내리기 <sup>12.5절</sup>
  - 슈퍼클래스에는 공통이 되는 부분만 남겨두고, 나머지는 서브클래스로 이동
- 서브클래스를 위임으로 바꾸기 <sup>12.10절</sup>
- 슈퍼클래스를 위임으로 바꾸기 <sup>12.11절</sup>


## 3.24 주석 (Comments)

주석은 악취가 아닌 향기를 입힘
잘못된 코드에서 발생한 악취를, 주석을 이용해 덮으려는 시도가 잘못된 것
주석은 현재 왜 이렇게 작성되었는지 이유를 설명해주는 역할
- 함수 추출하기 <sup>6.1절</sup>
- 함수 선언 바꾸기 <sup>6.5절</sup>
- 어서션 추가하기 <sup>10.6절</sup>
