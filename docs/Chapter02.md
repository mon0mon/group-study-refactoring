# Chapter 2 리팩터링 원칙

<details>
<summary>목차</summary>

<!-- TOC -->
* [Chapter 2 리팩터링 원칙](#chapter-2-리팩터링-원칙)
  * [2.1 리팩터링 정의](#21-리팩터링-정의)
  * [2.2 두 개의 모자](#22-두-개의-모자)
  * [2.3 리팩터링하는 이유](#23-리팩터링하는-이유)
    * [리팩터링하면 소프트웨어 설계가 좋아진다](#리팩터링하면-소프트웨어-설계가-좋아진다)
    * [리팩터링하면 소프트웨어를 이해하기 쉬워진다](#리팩터링하면-소프트웨어를-이해하기-쉬워진다)
    * [리팩터링하면 버그를 쉽게 찾을 수 있다](#리팩터링하면-버그를-쉽게-찾을-수-있다)
    * [리팩터링하면 프로그래밍 속도를 높일 수 있다](#리팩터링하면-프로그래밍-속도를-높일-수-있다)
  * [2.4 언제 리팩터링해야 할까?](#24-언제-리팩터링해야-할까)
    * [3의 법칙](#3의-법칙)
    * [준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기](#준비를-위한-리팩터링-기능을-쉽게-추가하게-만들기)
    * [이해를 위한 리팩터링: 코드 이해하기 쉽게 만들기](#이해를-위한-리팩터링-코드-이해하기-쉽게-만들기)
    * [쓰레기 줍기 리팩터링](#쓰레기-줍기-리팩터링)
    * [계획된 리팩터링과 수시로 하는 리팩터링](#계획된-리팩터링과-수시로-하는-리팩터링)
    * [오래 걸리는 리팩터링](#오래-걸리는-리팩터링)
    * [코드 리뷰에 리팩터링 활용하기](#코드-리뷰에-리팩터링-활용하기)
    * [관리자에게는 뭐라고 말해야 할까?](#관리자에게는-뭐라고-말해야-할까)
    * [리팩터링하지 말아야 할 때](#리팩터링하지-말아야-할-때)
  * [2.5 리팩터링 시 고려할 문제](#25-리팩터링-시-고려할-문제)
    * [새 기능 개발 속도 저하](#새-기능-개발-속도-저하)
      * [상황 예시](#상황-예시)
      * [해결 방안](#해결-방안)
    * [코드 소유권](#코드-소유권)
    * [브랜치](#브랜치)
    * [테스팅](#테스팅)
    * [레거시 코드](#레거시-코드)
    * [데이터베이스](#데이터베이스)
  * [2.6 리팩터링, 아키텍쳐, 애자일](#26-리팩터링-아키텍쳐-애자일)
  * [2.7 리팩터링과 소프트웨어 개발 프로세스](#27-리팩터링과-소프트웨어-개발-프로세스)
  * [2.8 리팩터링과 성능](#28-리팩터링과-성능)
  * [2.9 리팩터링의 유래](#29-리팩터링의-유래)
  * [2.10 리팩터링 자동화](#210-리팩터링-자동화)
  * [2.11 더 알고 싶다면](#211-더-알고-싶다면)
<!-- TOC -->

</details>

## 2.1 리팩터링 정의

| 리팩터링(Refactoring)
- [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
- [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

리팩터링은 **특정한 방식**에 따라 코드를 정리하는 것을 말함
- 동작을 보존하는 작은 단계로 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 이끌어내는 일
- 개별 리팩터링은 작을 수 있고, 여러 개가 합쳐진 모습일 수 있음
- 또한 리팩터링 과정에는 항상 코드가 <u>정상 작동</u>을 해야함

재구성(Restructuring)
- 코드 베이스를 정리하고, 구조를 변경하는 모든 작업
- 리팩토링보다 포괄적인 개념

리팩터링 시 세분화된 구조로 작업해야 효율적인 처리가 가능
- 체계적인 구성
- 디버깅 시 유용

겉보기 동작(Observable Behavior)
- 리팩토링 전과 후의 코드가 동일하게 동작함을 의미

예시
- 함수 추출하기<sup>6.1절</sup>
    - 콜스택 변경으로 인한 성능 변동 가능
    - 사용자 관점에서는 변경사항이 없음
- 함수 선언 바꾸기<sup>6.5절</sup>, 함수 옮기기<sup>8.1절</sup>
    - 리팩터링 과정에서 발견된 버그는 리팩터링 후에도 남아 있음

리팩터링과 성능최적화의 차이
- 리팩터링: 코드의 이해 및 수정이 용이한 상태로 변경하는 것
- 성능최적화: 속도 개선을 위해 변경하는 것

`*` 성능 최적화의 결과로 코드의 가독성이 악화되고, 유지보수성이 떨어질 수 있음


## 2.2 두 개의 모자

1. 기능추가
    - 기존 코드 수정 없이 새로운 기능 추가
    - 테스트 추가 후 통과여부를 통해 진척도 확인
2. 리팩터링
    - 기능추가 없이 코드의 재구성에 집중
    - 부득이한 경우를 제외하고, 테스트를 추가하지 않음

소프트웨어 개발 간에는 두 개의 모자를 번걸아가며 착용
현재 `어떤 모자를 쓰고 있는지`, 그리고 그 `모자에 따른 작업방식의 차이`를 인지해야함


## 2.3 리팩터링하는 이유

### 리팩터링하면 소프트웨어 설계가 좋아진다

소프트웨어는 시간이 지남에 따라 내부 설계가 썩기 쉬움<br>
원인으로는 `아키텍쳐 이해 부족`과 `단기 목표를 위한 코드 수정`이 있음

이러한 악순환의 반복으로 인해 코드의 부패는 더욱 빨라짐<br>

악순환을 막히 위해서는 규칙적인 리팩토링이 필요함<br>
나쁜 설계로 인해 발생한 중복 코드 제거로, 코드의 고유한 일을 보장할 수 있음


### 리팩터링하면 소프트웨어를 이해하기 쉬워진다

프로그램의 동작에만 집중하면, 코드를 다루는 개발자를 배려하지 못할 수 있음<br>
코드를 다루는 개발자가 읽기 쉽도록, 코드의 목적을 분명하게 전달하도록 개선해야함


### 리팩터링하면 버그를 쉽게 찾을 수 있다

리팩터링을 통해서, 코드의 역할 및 프로그램의 구조를 파악하기 쉬워짐<br>
이 때 버그도 분명히 드러나게 됨


### 리팩터링하면 프로그래밍 속도를 높일 수 있다

[설계 지구력 가설(Design Stamina Hypothesis)](https://martinfowler.com/bliki/DesignStaminaHypothesis.html)
- 리팩터링을 통해 오히려 속도를 높일 수 있음
- 리팩터링에 사용되는 시간보다, 더 많은 시간을 아끼게 될 수 있음
  - 코드의 이해도가 높아지고, 수정이 쉬워지기 때문

과거에는 코딩하기 전 설계를 완벽하게 맞춰야했지만, 지금은 리팩터링으로 구조 개선 가능<br>
좋은 설계를 유지하기 위해서는 리팩터링을 통해서 가능


## 2.4 언제 리팩터링해야 할까?

### 3의 법칙
1. 처음엔 그냥 한다
2. 비슷한 일을 두 번째로 하게 될 때, 일단 계속 진행한다.
3. 세 번째로 비슷한 일을 하게 되면, 리팩터링한다.

### 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기

요구사항을 만족하지만, 리터럴 값이 방해되는 함수가 있을 경우<br>
함수 매개변수화하기<sup>11.2절</sup>를 적용

오류를 일으키는 코드가 여러 곳에 중복하고 있을 때, 한 곳으로 합쳐서 작업하기<br>
이처럼 준비를 위한 리팩터링(Preparatory Refactoring)을 통해, 버그 빈도와 지속성을 줄일 수 있음

### 이해를 위한 리팩터링: 코드 이해하기 쉽게 만들기

이해를 위한 리팩터링(Comprehension Refactoring)을 통해, 코드의 목적을 분명하게 전달할 수 있음
- 목적에 맞는 이름으로 변경하기
- 긴 함수를 작은 함수로 분리하기

### 쓰레기 줍기 리팩터링

쓰레기 줍기 리팩터링(Litter-Pickup Refactoring)
- 코드를 수정할 때, 주변 코드를 정리하는 작업
- 시간을 지나치게 낭비하지 않기위해 간단한 수정은 즉시 적용하고, 나머지는 메모를 통해 다음 리팩터링에서 작업할 수 있도록 함

### 계획된 리팩터링과 수시로 하는 리팩터링

리팩터링은 수시로 하는 것이 좋지만, 계획 하에 진행된 리팩터링도 좋음<br>
정기적으로 리팩터링을 하더라도, 코드가 부패할 수 있기때문에 수시로 리팩터링을 하는 것이 좋음


### 오래 걸리는 리팩터링

리팩터링은 시간이 오래 걸리는 작업일 수 있음<br>
대규모 리팩터링에도 팀 전체가 작업하기보다는 기간을 가지고, 조금씩 작업해나가는 것이 효과적

추상화로 갈아타기(Branch by Abstraction)
- 기존 코드와 신규 코드를 모두 포용하는 인터페이스 방식
- 기존 코드가 추상 인터페이스를 호출하도록 변경하여 라이브러리를 교체하는 방식


### 코드 리뷰에 리팩터링 활용하기

코드 리뷰를 활용해, 추가적인 리팩터링 진행
- 리뷰어가 리팩터링을 통해 코드를 이해하는 과정으로 활용 가능
- 개선안 제시 뿐만 아니라, 구현을 통해 적극적으로 코드 리뷰에 참여 가능

P.S 풀 요청 모델(Pull Request Model)보다 짝 프로그래밍(Pair Programming)이 더 효과적일 수 있음


### 관리자에게는 뭐라고 말해야 할까?

개발자의 역할을 효과적인 소프트웨어를 가능한 빨리 만드는 것<br>
따라서 리팩터링을 통해, 빠른 작업 속도를 유지할 수 있도록 할 필요가 있음


### 리팩터링하지 말아야 할 때

- 수정의 필요성이 낮을 때

`*` 내부 동작을 이해할 시점에 리팩터링을 진행해야 효과적


## 2.5 리팩터링 시 고려할 문제

### 새 기능 개발 속도 저하

| 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 적은 노력으로 더 많은 가치를 창출하는 것

상황에 맞게끔 조율해야한다는 점에서, 리팩터링을 적용하는 가장 큰 걸림돌이 됨

#### 상황 예시
- (대대적인) 리팩터링이 필요하지만, 추가 기능이 작을 경우

#### 해결 방안
- 기능 추가의 도움을 줄 수 있는 리팩터링의 경우, 리팩터링을 진행
- 기능 추가와 관련이 없거나, 불편함의 정도가 크지 않은 경우 리팩터링을 미룸
- 또한 개선 방안이 확실하지 않은 경우에도 리팩터링을 미룸
- 이 때 개선 방안이 확실해지면, 리팩터링을 적용

`*` 리팩토터링은 과한 경우가, 덜한 경우보다 더 효과적일 수 있음


### 코드 소유권

클라이언트가 사용하는 `공개된 인터페이스`의 경우 코드 소유권이 분리되어 있는 경우가 존재

이 때 코드 소유권으로 인해 리팩터링에 방해가 될 수 있음<br>

코드 소유권은 느슨하게 정하는 것이, 리팩터링을 효과적으로 진행할 수 있음<br>
이 경우 다음과 같은 소유권 모델이 적합할 수 있음

- 코드 소유권을 팀과 공유
  - 팀원은 팀이 소유한 코드를 수정할 수 있으며, 작성자가 아니더라도 가능
- 오픈 소스 개발 모델
  - 브랜치 분리를 통해, 코드를 수정 후 승인하는 방식


### 브랜치

기능 브랜치 방식
- 개별 브랜치에서 코드 작업이 오래 진행 될 수록, 병합이 어려워질 수 있음
- 이 때 통합(Integration)을 통해 해결할 수 있지만, 그럼에도 제한은 존재
- 위와 같은 제한으로 인해 지속적 통합(Continuous Integration)또는 트렁크 기반 개발(TBD)을 고려할 수 있음

CI
- 적용하기 위해서는, 검증되지 않은 코드가 시스템을 망치지 않도록 해야함
- 켄트 백은 CI와 리팩터링을 합쳐서 익스트림 프로그래밍(eXtream Programming)을 창시함
- CI를 완벽하게 적용하지 못하더라도, 통합 주기는 최대한 짧게 가져가는 것이 유리

### 테스팅

리팩토링을 진행하면서, 실수로 오류가 발생할 수 있음<br>
이 때, 빠르게 오류를 찾아내기 위해, 코드의 다양한 측면을 검사하는 테스트 스위트(test suite)가 필요<br>
`*`[자가 테스트 코드(self-testing code)](https://martinfowler.com/bliki/SelfTestingCode.html) 필요

테스트 코드를 통한 이점
- 리팩터링 시 유용함
- 신규 기능 추가시 안전하게 진행할 수 있음
- 발생한 버그를 최근 변경사항에서 추적 가능
- 지속적 배포(Continuous Deployment)의 핵심이자, XP에서의 권장사항


### 레거시 코드

레거시 코드를 파악할 때, 리팩터링을 진행하여 도움을 얻을 수 있음<br>
대규모 레거시 시스템은 테스트 코드 없이 명료하게 리팩토링하기 어려움

레거시 코드를 리팩터링할 경우 [레거시 코드 활용 전략](https://product.kyobobook.co.kr/detail/S000001804724)을 참고하여 진행
- 프로그램에서 테스트를 추가할 틈새를 찾아서, 시스템을 테스트
- 위와 같은 상황을 예방하기 위해, 처음부터 자가 테스트 코드를 추가하는 것을 권장
- 서로 관련된 부부끼리 나눠서, 하나씩 리팩터링을 진행할 것
- 자주 보는 부분을 더 많이 리팩터링 할 것


### 데이터베이스

데이터베이스에도 리팩터링을 적용할 수 있음<br>
[진화형 데이터베이스 설계(Evolutionary Database Design)](https://martinfowler.com/articles/evodb.html)과 [데이터베이스 리팩터링](https://databaserefactoring.com/)을 참고
- 커다란 변경을 쉽게 조합하고 다룰 수 있는 마이그레이션 스크립트를 작성
- 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 스크립트로 처리
- 데이터베이스 리팩터링 역시 작고 독립된 단계들로 나누어 진행하는 것이 좋음<br>
`*` 병렬 수정(Parallel Change) 또는 팽창-수축(Expand-Contract)


## 2.6 리팩터링, 아키텍쳐, 애자일

기존 소프트웨어 아키텍쳐에서는, 설계를 완료한 이후에 코딩에 들어가는 방식이 일반적이었음<br>
하지만 리팩터링을 통해서, 기존 설계를 개선하고, 새로운 설계를 적용할 수 있음<br>
리팩터링이 아키텍쳐에 주는 실질적인 효과는 요구사항의 변화에 자연스럽게 대응하도록 도와준다는 점이 있음

향후 변경에 유연하게 대처할 수 있는 방법은 유연성 메커니즘(Flexibility Mechanism)을 사용하는 것
- 범용적으로 사용하기 위해, 다양한 예상 시나리오를 고려하여 설계
- 하지만 이렇게 설계된 코드는 당장의 쓰임에 비해, 복잡하고 비효율적일 수 있음
- 코드를 잘못 구현하거나, 요구사항을 변경 또는 매커니즘에 결함등이 원인

이런 유연성 메커니즘 한계를 극복하기 위해 리팩터링을 활용할 수 있음
- 현재까지의 요구사항을 해결하는 코드를 작성
- 진행하면서 사용자의 요구사항에 대해 더 잘 이해하게 될 때, 아키텍쳐 역시 리팩터링
- 복잡도를 높이는 유연성 매커니즘의 경우 검증을 거친 후 추가<br>
`*` 간결한 설계(Simple Design), 점진적 설계(Incremental Design), YAGNI(You Aren't Gonna Need It)

아키텍쳐를 전혀 고려하지 않는 것이 아닌, 추후에 문제를 깊이 이해했을 때 적용하는 것이 효과적<br>
`*` [진화형 아키텍쳐(Evolutionary Architecture)](https://evolutionaryarchitecture.com/)

## 2.7 리팩터링과 소프트웨어 개발 프로세스

자가 테스트 코드와 리팩터링을 묶어서 `테스트 주도 개발(Test-Driven Development, TDD)`이라고 함

프로세스의 적용
- 자가 테스트 코드 (발생한 오류를 검증)
- 리팩터링이 다른 사람의 작업을 방해하지 않음 (CI)

## 2.8 리팩터링과 성능

리팩토링을 통해 성능이 떨어지는 경우가 있음<br>
다만 이 경우에 우선시 되는 것은 직관적인 설계임<br>
리팩터링을 통해서 성능을 튜닝하기가 더욱 쉬워짐

빠른 소프트웨어를 작성하는 3가지 방법
- 시간 예산 분배(Time Budgeting)
  - 설계를 여러 컴포넌트로 나누어, 컴포넌트별 자원을 할당
  - 할당된 자원을 초과해서, 컴포넌트를 작업할 수 없음
- 끊임 없는 관심
  - 높은 성능을 유지하기 위해, 지속적으로 관심을 가지며 코드를 수정
  - 코드를 수정할수록, 복잡도가 높아지며 다루기 어려워짐
- 프로파일링
  - 대부분의 프로그램은 전체 코드 중, 극히 일부에서 대부분의 시간을 소비
  - 프로파일링을 통해, 가장 큰 병목지점을 확인하고 성능 최적화를 진행

리팩터링이 잘 되어있을 때는, 성능 뉴닝에 필요한 시간을 높일 수 있음<br>
또한 프로파일링 시 성능과 관련된 구체적인 코드 범위를 좁힘으로 튜닝하기 쉬워짐<br>
리팩터링 단계에서는 성능이 느려질 수 있지만, 최종적으로 최적화에 도움을 주기 때문에, 더 빠른 소프트웨어가 될 수 있음

## 2.9 리팩터링의 유래

실력 있는 프로그래머는 주기적으로 자신의 코드를 리팩터링함<br>
처음부터 깔끔하게 작성할 수 없다는 것을 경험으로 알기 때문

## 2.10 리팩터링 자동화



## 2.11 더 알고 싶다면
